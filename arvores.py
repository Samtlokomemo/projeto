# -*- coding: utf-8 -*-
"""Projeto - Arveres

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZIU83ec_KivD8CrLnIjPiP8jV0v8CkHd

# Imports
"""

import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.animation as animation
import math
import random
import time
from IPython.display import HTML
from ipywidgets import interact, IntSlider
from collections import deque
from IPython.display import display, clear_output
from matplotlib.patches import Rectangle, Circle, Polygon

"""# BST"""

def bstTree(search_num=None, add_nodes=None, visualize=True):
    """
    Cria e manipula uma Árvore Binária de Busca (BST)

    Parâmetros:
    - search_num: valor a ser buscado na árvore (None para não buscar)
    - add_nodes: valor único ou lista de valores a serem adicionados (None para não adicionar)
    - visualize: booleano para controlar se a visualização deve ser exibida

    Retorna:
    - A instância da BST e o resultado da busca (se aplicável)
    """
    class Node:
        def __init__(self, key):
            self.key = key
            self.left = None
            self.right = None

    class BST:
        def __init__(self):
            self.root = None

        def insert(self, keys):
            """Insere um ou vários nós na BST"""
            if isinstance(keys, (list, tuple)):
                for key in keys:
                    self._insert_single(key)
            else:
                self._insert_single(keys)

        def _insert_single(self, key):
            """Insere um único nó na BST"""
            if self.root is None:
                self.root = Node(key)
            else:
                self._insert_recursive(self.root, key)

        def _insert_recursive(self, node, key):
            """Método auxiliar recursivo para inserção"""
            if key < node.key:
                if node.left is None:
                    node.left = Node(key)
                else:
                    self._insert_recursive(node.left, key)
            elif key > node.key:
                if node.right is None:
                    node.right = Node(key)
                else:
                    self._insert_recursive(node.right, key)

        def search(self, key):
            """Busca um nó na BST e retorna o nó se encontrado"""
            return self._search_recursive(self.root, key)

        def _search_recursive(self, node, key):
            """Método auxiliar recursivo para busca"""
            if node is None or node.key == key:
                return node
            if key < node.key:
                return self._search_recursive(node.left, key)
            return self._search_recursive(node.right, key)

        def knuth_in_order(self):
            """Algoritmo de Knuth para caminhamento in-order sem recursão"""
            stack = []
            node = self.root
            result = []

            while True:
                while node is not None:
                    stack.append(node)
                    node = node.left

                if not stack:
                    break

                node = stack.pop()
                result.append(node.key)
                node = node.right

            return result

        def visualize(self, highlight_key=None):
            """Visualiza a BST com destaque para um nó específico"""
            G = nx.DiGraph()
            queue = deque([self.root])
            color_map = []

            while queue:
                node = queue.popleft()
                if node is None:
                    continue

                G.add_node(node.key)

                if highlight_key is not None and node.key == highlight_key:
                    color_map.append('limegreen')
                else:
                    color_map.append('skyblue')

                if node.left:
                    G.add_edge(node.key, node.left.key)
                    queue.append(node.left)
                if node.right:
                    G.add_edge(node.key, node.right.key)
                    queue.append(node.right)

            pos = self._hierarchy_pos(G, self.root.key)
            plt.figure(figsize=(10, 6))
            nx.draw(G, pos, with_labels=True, node_size=2000, node_color=color_map,
                    font_size=10, font_weight='bold', arrows=True)
            plt.title("Visualização da Árvore BST" +
                     (f" (Nó {highlight_key} encontrado)" if highlight_key else ""))
            plt.show()

        def _hierarchy_pos(self, G, root, width=1., vert_gap=0.2, vert_loc=0, xcenter=0.5):
            """Cria posições hierárquicas para os nós na visualização"""
            pos = {root: (xcenter, vert_loc)}
            neighbors = list(G.neighbors(root))
            if len(neighbors) != 0:
                dx = width/len(neighbors)
                nextx = xcenter - width/2 - dx/2
                for neighbor in neighbors:
                    nextx += dx
                    pos.update(self._hierarchy_pos(G, neighbor, width=dx, vert_gap=vert_gap,
                                                vert_loc=vert_loc-vert_gap, xcenter=nextx))
            return pos

    # Cria a BST e insere os valores padrão
    bst = BST()
    default_values = [50, 30, 70, 20, 40, 60, 80, 15, 25, 35, 45]
    bst.insert(default_values)

    # Adiciona novos nós se especificado
    if add_nodes is not None:
        bst.insert(add_nodes)

    # Realiza a busca se especificado
    search_result = None
    if search_num is not None:
        search_result = bst.search(search_num)
        print(f"\nBusca por {search_num}:", "Encontrado" if search_result else "Não encontrado")

    # Exibe o caminhamento in-order
    print("Caminhamento in-order usando algoritmo de Knuth:")
    print(bst.knuth_in_order())

    # Visualiza a árvore se solicitado
    if visualize:
        highlight = search_num if search_result else None
        bst.visualize(highlight_key=highlight)

    return bst, search_result

"""# AVL"""

import matplotlib.pyplot as plt
import networkx as nx

def avlTree(add_numbers=None):
    class Node:
        def __init__(self, key):
            self.key = key
            self.left = None
            self.right = None
            self.height = 1

    class AVLTree:
        def __init__(self):
            self.root = None

        def insert(self, key):
            self.root = self._insert(self.root, key)

        def _insert(self, node, key):
            if not node:
                return Node(key)
            elif key < node.key:
                node.left = self._insert(node.left, key)
            else:
                node.right = self._insert(node.right, key)

            node.height = 1 + max(self._get_height(node.left),
                                self._get_height(node.right))

            balance = self._get_balance(node)

            if balance > 1 and key < node.left.key:
                return self._right_rotate(node)
            if balance < -1 and key > node.right.key:
                return self._left_rotate(node)
            if balance > 1 and key > node.left.key:
                node.left = self._left_rotate(node.left)
                return self._right_rotate(node)
            if balance < -1 and key < node.right.key:
                node.right = self._right_rotate(node.right)
                return self._left_rotate(node)

            return node

        def _left_rotate(self, z):
            y = z.right
            T2 = y.left

            y.left = z
            z.right = T2

            z.height = 1 + max(self._get_height(z.left),
                              self._get_height(z.right))
            y.height = 1 + max(self._get_height(y.left),
                              self._get_height(y.right))

            return y

        def _right_rotate(self, z):
            y = z.left
            T3 = y.right

            y.right = z
            z.left = T3

            z.height = 1 + max(self._get_height(z.left),
                              self._get_height(z.right))
            y.height = 1 + max(self._get_height(y.left),
                              self._get_height(y.right))

            return y

        def _get_height(self, node):
            if not node:
                return 0
            return node.height

        def _get_balance(self, node):
            if not node:
                return 0
            return self._get_height(node.left) - self._get_height(node.right)

        def visualize(self):
            G = nx.DiGraph()

            def add_edges(node, parent=None):
                if node:
                    if parent is not None:
                        G.add_edge(parent.key, node.key)
                    add_edges(node.left, node)
                    add_edges(node.right, node)

            add_edges(self.root)

            pos = self._hierarchy_pos(G, self.root.key) if self.root else {}

            plt.figure(figsize=(10, 7))
            nx.draw(G, pos, with_labels=True, arrows=False,
                    node_size=2500, node_color='skyblue',
                    font_size=15, font_weight='bold')
            plt.title("Visualização da Árvore AVL")
            plt.show()

        def _hierarchy_pos(self, G, root, width=1., vert_gap=0.2, vert_loc=0, xcenter=0.5):
            pos = {root: (xcenter, vert_loc)}
            neighbors = list(G.neighbors(root))
            if len(neighbors) != 0:
                dx = width/2
                nextx = xcenter - width/2 - dx/2
                for neighbor in neighbors:
                    nextx += dx
                    pos.update(self._hierarchy_pos(G, neighbor, width=dx, vert_gap=vert_gap,
                                                vert_loc=vert_loc-vert_gap, xcenter=nextx))
            return pos

    avl = AVLTree()
    default_keys = [10, 20, 30, 40, 50, 25, 15, 5]

    # Inserindo valores padrão um por um
    for key in default_keys:
        avl.insert(key)

    # Inserindo números adicionais se fornecidos
    if add_numbers is not None:
        if isinstance(add_numbers, (list, tuple)):
            for num in add_numbers:
                avl.insert(num)
        else:
            avl.insert(add_numbers)

    print("Árvore AVL construída. Visualizando...")
    avl.visualize()
    return avl

"""# Arvore B"""

def bTree(add_num = None, search_num = None, grau = 2):
    class BTreeNode:
        def __init__(self, leaf=False):
            self.keys = []
            self.children = []
            self.leaf = leaf

        def __repr__(self):
            return f"BTreeNode(keys={self.keys}, leaf={self.leaf})"

    class BTree:
        def __init__(self, t):
            self.root = BTreeNode(leaf=True)
            self.t = t  # Grau mínimo da árvore

        def insert(self, key):
            root = self.root
            if len(root.keys) == (2 * self.t) - 1:
                new_root = BTreeNode()
                self.root = new_root
                new_root.children.append(root)
                self._split_child(new_root, 0)
                self._insert_non_full(new_root, key)
            else:
                self._insert_non_full(root, key)

        def _insert_non_full(self, node, key):
            i = len(node.keys) - 1
            if node.leaf:
                node.keys.append(None)
                while i >= 0 and key < node.keys[i]:
                    node.keys[i + 1] = node.keys[i]
                    i -= 1
                node.keys[i + 1] = key
            else:
                while i >= 0 and key < node.keys[i]:
                    i -= 1
                i += 1
                if len(node.children[i].keys) == (2 * self.t) - 1:
                    self._split_child(node, i)
                    if key > node.keys[i]:
                        i += 1
                self._insert_non_full(node.children[i], key)

        def _split_child(self, parent, index):
            t = self.t
            child = parent.children[index]
            new_node = BTreeNode(leaf=child.leaf)

            parent.keys.insert(index, child.keys[t - 1])
            parent.children.insert(index + 1, new_node)

            new_node.keys = child.keys[t:(2 * t - 1)]
            child.keys = child.keys[0:(t - 1)]

            if not child.leaf:
                new_node.children = child.children[t:(2 * t)]
                child.children = child.children[0:t]

        def search(self, key, node=None):
            if node is None:
                node = self.root

            i = 0
            while i < len(node.keys) and key > node.keys[i]:
                i += 1

            if i < len(node.keys) and key == node.keys[i]:
                return (node, i)
            elif node.leaf:
                return None
            else:
                return self.search(key, node.children[i])

        def visualize(self, search_key=None):
            fig, ax = plt.subplots(figsize=(12, 8))
            ax.set_aspect('equal')
            ax.axis('off')

            if not self.root.keys:
                ax.text(0.5, 0.5, "Árvore vazia", ha='center', va='center')
                plt.show()
                return

            # Verifica se a chave de busca existe
            found_node = None
            found_index = -1
            if search_key is not None:
                search_result = self.search(search_key)
                if search_result is not None:
                    found_node, found_index = search_result

            # Calcula as posições dos nós
            positions = {}
            levels = {}
            self._calculate_positions(self.root, 0, 0, positions, levels)

            # Desenha as conexões primeiro (para ficarem atrás dos nós)
            max_level = max(levels.values()) if levels else 0
            for node in positions:
                if not node.leaf:
                    x, y = positions[node]
                    for i, child in enumerate(node.children):
                        if child in positions:
                            cx, cy = positions[child]
                            # Desenha a linha até o topo do nó filho
                            plt.plot([x, cx], [y - 0.1, cy + 0.1], 'k-', lw=1)

            # Desenha os nós
            for node in positions:
                x, y = positions[node]
                # Se for o nó encontrado na busca, destaque
                is_found_node = (node == found_node)
                self._draw_node(ax, node, x, y, is_found_node, found_index)

            # Adiciona legenda se estiver buscando uma chave
            if search_key is not None:
                if found_node is not None:
                    title = f"Chave {search_key} encontrada na árvore"
                else:
                    title = f"Chave {search_key} não encontrada na árvore"
                plt.title(title, fontsize=14, pad=20)

            plt.tight_layout()
            plt.show()

        def _calculate_positions(self, node, x, level, positions, levels, spacing=2.0):
            if node is None:
                return x

            # Calcula a posição dos filhos
            child_x = x
            child_positions = []
            if not node.leaf:
                for child in node.children:
                    child_x = self._calculate_positions(child, child_x, level + 1, positions, levels, spacing)
                    child_positions.append(child_x)

            # Posição atual do nó (centro entre os filhos extremos)
            if child_positions:
                node_x = (child_positions[0] + child_positions[-1]) / 2
            else:
                node_x = x

            positions[node] = (node_x, -level)
            levels[node] = level

            # Retorna a posição mais à direita para o próximo irmão
            if node.leaf:
                return x + len(node.keys) * 0.5 + 0.5
            else:
                return child_x

        def _draw_node(self, ax, node, x, y, is_found_node=False, found_index=-1):
            # Desenha o retângulo do nó
            num_keys = len(node.keys)
            width = num_keys * 0.5
            height = 0.4

            # Cor diferente para o nó encontrado
            facecolor = 'lightgreen' if is_found_node else 'lightyellow'
            rect = Rectangle((x - width/2, y - height/2), width, height,
                            facecolor=facecolor, edgecolor='black', lw=1)
            ax.add_patch(rect)

            # Desenha as chaves
            for i, key in enumerate(node.keys):
                key_x = x - width/2 + 0.25 + i * 0.5
                # Destaca a chave encontrada
                if is_found_node and i == found_index:
                    ax.text(key_x, y, str(key), ha='center', va='center',
                          fontsize=10, weight='bold', bbox=dict(facecolor='yellow', alpha=0.7))
                else:
                    ax.text(key_x, y, str(key), ha='center', va='center', fontsize=10)

    btree = BTree(t = grau)
    keys = [10, 20, 5, 6, 12, 30, 7, 17, 3, 8, 15, 25]
    for key in keys:
        btree.insert(key)

    if add_num is not None:
      if isinstance(add_num, (list, tuple)):
          for num in add_num:
              btree.insert(num)
      else:
          btree.insert(add_num)

    if search_num is not None:
      result = btree.search(search_num)

    if result:
        node, index = result
        print(f"Chave encontrada no nó: {node.keys}, na posição {index}")
    else:
        print("Chave não encontrada na árvore")

    # Visualizando a árvore
    print("Árvore B criada com chaves:", keys)
    btree.visualize()

"""# Fibonacci"""

def fiboTree(num):
  # --- Função Fibonacci com Memoização ---
  fib_memo = {0: 0, 1: 1}
  def fibonacci(n):
      if n < 0:
          return 0
      if n not in fib_memo:
          fib_memo[n] = fibonacci(n-1) + fibonacci(n-2)
      return fib_memo[n]

  # --- Função para Calcular a Largura da Subárvore ---
  def calculate_subtree_width(n, depth, max_depth):
      if n <= 1 or depth >= max_depth:
          return 1
      return calculate_subtree_width(n-1, depth+1, max_depth) + calculate_subtree_width(n-2, depth+1, max_depth)

  # --- Função para Desenhar a Árvore ---
  def draw_fibonacci_tree(n, x, y, depth, width, vertical_spacing, max_depth, scale_factor=1.0):
      fib_val = fibonacci(n)

      # Condição de parada para nós não relevantes
      if fib_val <= 0 and n != 1:
          return

      # --- Desenho do Nó Atual ---
      base_font_size = 14
      font_size = max(base_font_size - depth * 0.8, 8) * scale_factor
      node_size = 0.15 * scale_factor

      plt.text(x, y, str(fib_val),
              ha='center', va='center',
              fontsize=font_size,
              color='black',
              fontweight='bold',
              zorder=2,
              bbox=dict(facecolor='lightgreen',
                        edgecolor='black',
                        boxstyle='circle',
                        pad=node_size))

      # --- Condição de Parada da Recursão ---
      if n > 1 and depth < max_depth:
          new_y = y - vertical_spacing * scale_factor

          # Calcula as larguras das subárvores
          left_width = calculate_subtree_width(n-1, depth+1, max_depth)
          right_width = calculate_subtree_width(n-2, depth+1, max_depth)
          total_width = left_width + right_width

          # Calcula posições baseadas nas larguras das subárvores
          left_offset = (right_width / total_width) * width
          right_offset = (left_width / total_width) * width

          new_x_left = x - left_offset/2
          new_x_right = x + right_offset/2

          # --- Filho Esquerdo (F(n-1)) ---
          fib_left = fibonacci(n - 1)
          if fib_left > 0 or (n - 1) == 1:
              plt.plot([x, new_x_left], [y, new_y], 'k-', lw=1.2*scale_factor, zorder=1)
              draw_fibonacci_tree(n - 1, new_x_left, new_y, depth + 1,
                                left_width, vertical_spacing, max_depth, scale_factor)

          # --- Filho Direito (F(n-2)) ---
          fib_right = fibonacci(n - 2)
          if fib_right > 0 or (n - 2) == 1:
              plt.plot([x, new_x_right], [y, new_y], 'k-', lw=1.2*scale_factor, zorder=1)
              draw_fibonacci_tree(n - 2, new_x_right, new_y, depth + 1,
                                right_width, vertical_spacing, max_depth, scale_factor)

  # --- Configurações ---
  n_inicial = num
  max_depth = 7
  vertical_spacing = 2.0  # Aumentado para melhor espaçamento
  scale_factor = 1.5      # Fator de escala para aumentar nós e texto

  # Calcula a largura total necessária
  total_width = calculate_subtree_width(n_inicial, 0, max_depth)

  # Ajusta o tamanho da figura com base na largura total e profundidade
  fig_width = total_width * 0.7 * scale_factor
  fig_height = max_depth * 1.5 * scale_factor

  plt.figure(figsize=(fig_width, fig_height))
  plt.axis('off')
  plt.gca().invert_yaxis()  # Faz a árvore crescer para baixo

  # Limpa o cache
  fib_memo = {0: 0, 1: 1}

  # Desenha a árvore
  draw_fibonacci_tree(n_inicial, 0, 0, 0, total_width, vertical_spacing, max_depth, scale_factor)

  plt.title(f"Árvore de Fibonacci para F({n_inicial}) - Versão Final", pad=20, fontsize=14*scale_factor)
  plt.gca().set_aspect('equal')
  plt.tight_layout()
  plt.show()

"""# Programa"""

#fiboTree(8)
#bstTree(19, [19, 10, 21])
#avlTree([1, 2, 55])
#bTree(13, 5)
