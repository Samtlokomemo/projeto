# -*- coding: utf-8 -*-
"""Projeto - Listas

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yRS040Vz3SI2yn-Qf5XKtldV40Nri5xL

# Imports
"""

import matplotlib.pyplot as plt
import numpy as np
from IPython.display import display, clear_output
import time
import random

"""# Listas auto organizaveis"""

class SelfOrganizingList:
    def __init__(self):
        self.items = []

    def __len__(self):
        return len(self.items)

    def __str__(self):
        return str(self.items)

    def is_empty(self):
        return len(self.items) == 0

    def insert(self, item):
        self.items.insert(0, item)

    def search(self, item):
        raise NotImplementedError("Subclasses should implement this!")

    def visualize(self, title="", highlight=None):
        plt.figure(figsize=(10, 2))
        plt.title(title)

        for i, val in enumerate(self.items):
            if highlight is not None and val == highlight:
                plt.barh(0, 1, left=i, height=0.6, color='red', alpha=0.7)
                plt.text(i + 0.5, 0, str(val), ha='center', va='center', color='white', fontweight='bold')
            else:
                plt.barh(0, 1, left=i, height=0.6, color='skyblue', alpha=0.7)
                plt.text(i + 0.5, 0, str(val), ha='center', va='center')

        plt.xlim(0, len(self.items))
        plt.ylim(-1, 1)
        plt.axis('off')
        plt.show()


class MoveToFrontList(SelfOrganizingList):
    def search(self, item):
        for i in range(len(self.items)):
            if self.items[i] == item:
                # Move to front
                self.items.pop(i)
                self.items.insert(0, item)

                # Visualize the step
                self.visualize(f"Move to Front: {item}", item)
                time.sleep(1)
                return True

        return False


class TransposeList(SelfOrganizingList):
    def search(self, item):
        for i in range(len(self.items)):
            if self.items[i] == item:
                if i > 0:  # Not already at the front
                    # Swap with previous element
                    self.items[i], self.items[i-1] = self.items[i-1], self.items[i]

                    # Visualize the step
                    self.visualize(f"Transpose: {item}", item)
                    time.sleep(1)
                return True

        return False

def autoList(searchNum = None, transposeNum = None, tamanho = 10):
  # Criar e demonstrar a lista Move-to-Front
  mtf_list = MoveToFrontList()
  for i in range(tamanho, 0, -1):
      mtf_list.insert(i)

  print("Lista Move-to-Front inicial:")
  mtf_list.visualize("Lista Move-to-Front inicial")

  # Realizar algumas buscas
  if searchNum is not None:
    mtf_list.search(searchNum)

  # Criar e demonstrar a lista Transpose
  transpose_list = TransposeList()
  for i in range(10, 0, -1):
      transpose_list.insert(i)

  print("\nLista Transpose inicial:")
  transpose_list.visualize("Lista Transpose inicial")

  # Realizar algumas buscas
  if transposeNum is not None:
    transpose_list.search(transposeNum)

#autoList(3, 9, 15)

"""# Skip Lists"""

class SkipNode:
    def __init__(self, value=None, level=0):
        self.value = value
        self.forward = [None] * (level + 1)

class SkipList:
    def __init__(self, max_level=4, p=0.5):
        self.max_level = max_level
        self.p = p
        self.header = SkipNode(None, max_level)
        self.level = 0

    def random_level(self):
        level = 0
        while random.random() < self.p and level < self.max_level:
            level += 1
        return level

    def insert(self, value):
        update = [None] * (self.max_level + 1)
        current = self.header

        for i in range(self.level, -1, -1):
            while current.forward[i] and current.forward[i].value < value:
                current = current.forward[i]
            update[i] = current

        current = current.forward[0]

        if current is None or current.value != value:
            new_level = self.random_level()

            if new_level > self.level:
                for i in range(self.level + 1, new_level + 1):
                    update[i] = self.header
                self.level = new_level

            new_node = SkipNode(value, new_level)

            for i in range(new_level + 1):
                new_node.forward[i] = update[i].forward[i]
                update[i].forward[i] = new_node

    def search(self, value):
      current = self.header
      path = []
      search_steps = []  # Para armazenar cada passo da busca

      for i in range(self.level, -1, -1):
          while current.forward[i] and current.forward[i].value < value:
              path.append((i, current.value if current.value is not None else "H"))
              current = current.forward[i]
              # Adiciona o passo atual à visualização
              search_steps.append((list(path), f"Procurando {value} no nível {i}"))

          path.append((i, current.value if current.value is not None else "H"))
          search_steps.append((list(path), f"Checando ponteiro no nível {i}"))

      current = current.forward[0]
      found = current and current.value == value
      path.append((0, current.value if found else "X"))

      # Visualiza cada passo da busca
      for step_path, step_desc in search_steps:
          self._visualize_search_step(step_path, value, step_desc, final=False)
          plt.pause(0.5)  # Pausa para visualização

      # Visualização final
      self._visualize_search_step(path, value,
                                f"Valor {value} {'encontrado!' if found else 'não encontrado!'}",
                                final=True)

      return found

    def visualize(self, title="Skip List"):
        fig, ax = plt.subplots(figsize=(10, 6))

        nodes = {}
        max_width = 0
        current = self.header.forward[0]
        x_pos = 0

        # Primeiro passada para determinar posições
        while current:
            nodes[current.value] = x_pos
            max_width = max(max_width, x_pos)
            x_pos += 1
            current = current.forward[0]

        # Desenhar os níveis de cima para baixo
        for level in range(self.level, -1, -1):
            current = self.header
            y = level + 1
            prev_x = -0.5

            # Desenhar o cabeçalho
            ax.text(-0.5, y, "H", ha='center', va='center',
                   bbox=dict(facecolor='skyblue', boxstyle='circle'))

            # Desenhar os nós
            while current.forward[level]:
                current = current.forward[level]
                x = nodes[current.value]

                # Desenhar a linha horizontal
                ax.plot([prev_x + 0.5, x], [y, y], 'b-', linewidth=1)

                # Desenhar o nó
                ax.text(x, y, str(current.value), ha='center', va='center',
                       bbox=dict(facecolor='lightgreen', boxstyle='circle'))

                prev_x = x

            # Desenhar a linha final do nível
            ax.plot([prev_x + 0.5, max_width + 0.5], [y, y], 'b-', linewidth=1)

        # Desenhar as linhas verticais entre nós
        for value, x in nodes.items():
            # Encontrar o nó em todos os níveis
            node = self.header
            while node.forward[0] and node.forward[0].value != value:
                node = node.forward[0]
            node = node.forward[0]

            # Desenhar linhas verticais
            top_level = len(node.forward) - 1
            ax.plot([x, x], [1, top_level + 1], 'b--', alpha=0.3)

        ax.set_xlim(-1, max_width + 1)
        ax.set_ylim(0, self.level + 2)
        ax.set_title(title)
        ax.axis('off')
        plt.show()

    def _visualize_search_step(self, path, value, description, final=False):
      plt.figure(figsize=(10, 6))

      nodes = {}
      max_width = 0
      current = self.header.forward[0]
      x_pos = 0

      # Mapear posições dos nós
      while current:
          nodes[current.value] = x_pos
          max_width = max(max_width, x_pos)
          x_pos += 1
          current = current.forward[0]

      # Desenhar cada nível
      for level in range(self.level, -1, -1):
          current = self.header
          y = level + 1
          prev_x = -0.5

          # Cabeçalho
          header_color = 'red' if (level, "H") in path else 'skyblue'
          plt.text(-0.5, y, "H", ha='center', va='center',
                bbox=dict(facecolor=header_color, boxstyle='circle'))

          # Nós
          while current.forward[level]:
              current = current.forward[level]
              x = nodes[current.value]

              # Verificar se este nó está no caminho
              node_in_path = (level, current.value) in path
              line_color = 'r-' if node_in_path else 'b-'
              node_color = 'red' if node_in_path else 'lightgreen'

              # Linha horizontal
              plt.plot([prev_x + 0.5, x], [y, y], line_color,
                      linewidth=2 if node_in_path else 1)

              # Nó
              plt.text(x, y, str(current.value), ha='center', va='center',
                    bbox=dict(facecolor=node_color, boxstyle='circle'))

              prev_x = x

          # Linha final do nível
          plt.plot([prev_x + 0.5, max_width + 0.5], [y, y], 'b-', linewidth=1)

      # Linhas verticais
      for val, x in nodes.items():
          node = self.header
          while node.forward[0] and node.forward[0].value != val:
              node = node.forward[0]
          node = node.forward[0]

          top_level = len(node.forward) - 1
          line_style = 'r--' if any((l, val) in path for l in range(top_level+1)) else 'b--'
          plt.plot([x, x], [1, top_level + 1], line_style, alpha=0.5)

      # Resultado
      plt.text(max_width/2, -0.5, description, ha='center', va='center',
            fontsize=12, color='green' if final and 'encontrado' in description else 'red',
            bbox=dict(facecolor='white', alpha=0.8))

      plt.xlim(-1, max_width + 1)
      plt.ylim(-1, self.level + 2)
      plt.title(f"Busca por: {value}")
      plt.axis('off')

      if final:
          plt.show()
      else:
          plt.draw()
          plt.pause(0.5)
          plt.close()

def skipList(search = None, insertNum = None, max = 4):
  # Criar e demonstrar a Skip List
  skip_list = SkipList(max_level = max)

  values = [3, 6, 7, 9, 12, 19, 17, 21, 25]
  for value in values:
      skip_list.insert(value)
  if insertNum is not None:
      if isinstance(insertNum, (list, tuple)):
          for num in insertNum:
              skip_list.insert(num)
      else:
          skip_list.insert(insertNum)

  if search is not None:
    skip_list.search(search)

  print("Skip List completa:")
  skip_list.visualize("Skip List Completa")

#skipList(17)